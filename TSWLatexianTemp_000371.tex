%
% 6.006 problem set 1 solutions template
%
\documentclass[12pt,twoside]{article}

\usepackage{amsmath}
\usepackage{color}

\input{macros}

\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\textwidth}{6.5in}
\setlength{\topmargin}{0in}
\setlength{\textheight}{8.5in}

\renewcommand\labelitemi {}

\newcommand{\theproblemsetnum}{1}
\newcommand{\releasedate}{Thursday, February 20}
\newcommand{\partaduedate}{Thursday, February 20}
\newcommand{\tabUnit}{3ex}
\newcommand{\tabT}{\hspace*{\tabUnit}}

\title{6.006 PSET 1}

\begin{document}

\handout{Problem Set \theproblemsetnum}{February 6, 2014}

\textbf{All parts are due {\bf \partaduedate} at {\bf 11:59PM}}.
%
Please download the .zip archive for this problem set, and refer to the
\texttt{README.txt} file for instructions on preparing your solutions.
%
Remember, your goal is to communicate. Full credit will be given only
to a correct solution which is described clearly. Convoluted and
obtuse descriptions might receive low marks, even when they are
correct. Also, aim for concise solutions, as it will save you time
spent on write-ups, and also help you conceptualize the key idea of
the problem.

\setlength{\parindent}{0pt}

\medskip

\hrulefill

\medskip

{\bf Your Name:} Eunice Wu

\medskip

{\bf Collaborators:} Rebekah Cha, Jordan Powell

\medskip

\hrulefill

\begin{problems}
\section*{Part A}
\problem
\begin{problemparts}
\problempart $f_1(n) < f_2(n) < f_3(n) < f_5(n) < f_4(n) $
\problempart $f_4(n) < f_5(n) < f_3(n) < f_1(n) < f_2(n)$
\problempart $f_1(n) < f_2(n) < f_3(n) < f_5(n) \sim f_4(n) $
\end{problemparts}

\problem
\begin{problemparts}
\problempart $\theta (x)$
\problempart $\theta (x\log (x))$
\problempart $\theta (y\log (x))$
\problempart $\theta (\log x\log y)$
\problempart $\theta (x+y)$
\end{problemparts}

\problem
\begin{problemparts}
\problempart The recurrence can be represented by a binary tree and therefore has a height O(log(number of columns)). Supposing that we have an array with dimensions n rows x m columns. Each step can be represented by 
\equation T(n,m) = \theta(n) +2T(n,m/2)$$
where $f(n)$, the time it takes to divide/combine and execute each step, is $\theta(n) $ because to find the peak, each step involves finding the maximum of each column which runs through all n rows of the current midpoint column and therefore is O(n).

\problempart 
\textit{ Assume}: Recursive call returns peak for subproblem (given by problem)\\
\textit{Base Case}: Number of Columns (m) = 1\\
The algorithm will terminate when passed the base case because each step is strictly smaller than the previous step.
At the base case case, it is also guaranteed to return the correct answer because, assuming that the method peakProblem.getMaximum() is correct, finding the maximum is the only step needed for the base case Peak Problem. In the case where there is no dividing line, the "getBetterNeighbor" function just returns the previous "bestLoc," so at m = 1, the algorithm is correct. \\
\textit{Inductive Step:} Let us assume that the algorithm is correct for an m-column array and all subarrays. We can add another column so that we are now at m+1 columns. There will be two cases upon finding the midpoint column's max:\\
\begin{itemize}
\item case 1: A neighbor is the better peak\\
If this is the case, then we will move on to apply the algorithm on that neighbor's corresponding $\frac{(m+1)}{2}$ column array which, since $m >=1$, is a sub array of an m-column array, and therefore would return the right answer with algorithm 3.\\
\item case 2: The previous stored bestLoc is returned\\
If this is the case, then 
\end{itemize}

\end{problemparts}

\problem
\begin{problemparts}
\problempart 
\end{problemparts}
\problem
\problem

\section*{Part B}

\emph{Submit your implemented python script.}

\end{problems}

\end{document}
